using System;
using System.Collections.Generic;
using System.Text.Parsing;
using Code;

namespace Syntax
{
    public class RuleGrammar : System.Text.Parsing.Grammar
    {
        public RuleGrammar() : this(new ParsingDomain())
        {
        }
        public RuleGrammar(ParsingDomain parsingDomain) : base("RuleGrammar", parsingDomain.GetNamespaceScope("Syntax"), parsingDomain)
        {
            Owner = 0;
            parsingDomain.AddGrammar(this);
            CreateRules();
            Link();
        }
        public class RuleRule : System.Text.Parsing.RuleParser
        {
            public RuleRule(string name, Scope enclosingScope, int id, Parser definition) : base(name, enclosingScope, id, definition)
            {
                InheritedAttributes.Add(new AttrOrVar("Scope", "enclosingScope"));
                InheritedAttributes.Add(new AttrOrVar("ParsingContext", "ctx"));
                ValueTypeName = "RuleParser";
            }
            public override void Enter(Stack<object> stack, ParsingData parsingData)
            {
                parsingData.PushContext(Id, new Context());
                Context context = cast<Context>(parsingData.GetContext(Id));
                context.ctx = cast<ParsingContext>(stack.Pop());
                context.enclosingScope = cast<Scope>(stack.Pop());
            }
            public override void Leave(Stack<object> stack, ParsingData parsingData, bool matched)
            {
                Context context = cast<Context>(parsingData.GetContext(Id));
                if (matched)
                {
                    stack.Push(context.value);
                }
                parsingData.PopContext(Id);
            }
            public override void Link()
            {
            }
            public class Context : System.Text.Parsing.Context
            {
                public Scope enclosingScope;
                public ParsingContext ctx;
                public RuleParser value;
            }
        }
        public class RuleHeaderRule : System.Text.Parsing.RuleParser
        {
            public RuleHeaderRule(string name, Scope enclosingScope, int id, Parser definition) : base(name, enclosingScope, id, definition)
            {
                InheritedAttributes.Add(new AttrOrVar("Scope", "enclosingScope"));
                InheritedAttributes.Add(new AttrOrVar("ParsingContext", "ctx"));
                ValueTypeName = "RuleParser";
            }
            public override void Enter(Stack<object> stack, ParsingData parsingData)
            {
                parsingData.PushContext(Id, new Context());
                Context context = cast<Context>(parsingData.GetContext(Id));
                context.ctx = cast<ParsingContext>(stack.Pop());
                context.enclosingScope = cast<Scope>(stack.Pop());
            }
            public override void Leave(Stack<object> stack, ParsingData parsingData, bool matched)
            {
                Context context = cast<Context>(parsingData.GetContext(Id));
                if (matched)
                {
                    stack.Push(context.value);
                }
                parsingData.PopContext(Id);
            }
            public override void Link()
            {
            }
            public class Context : System.Text.Parsing.Context
            {
                public Scope enclosingScope;
                public ParsingContext ctx;
                public RuleParser value;
            }
        }
        public class RuleBodyRule : System.Text.Parsing.RuleParser
        {
            public RuleBodyRule(string name, Scope enclosingScope, int id, Parser definition) : base(name, enclosingScope, id, definition)
            {
                InheritedAttributes.Add(new AttrOrVar("RuleParser", "rule"));
                InheritedAttributes.Add(new AttrOrVar("ParsingContext", "ctx"));
            }
            public override void Enter(Stack<object> stack, ParsingData parsingData)
            {
                parsingData.PushContext(Id, new Context());
                Context context = cast<Context>(parsingData.GetContext(Id));
                context.ctx = cast<ParsingContext>(stack.Pop());
                context.rule = cast<RuleParser>(stack.Pop());
            }
            public override void Leave(Stack<object> stack, ParsingData parsingData, bool matched)
            {
                Context context = cast<Context>(parsingData.GetContext(Id));
                parsingData.PopContext(Id);
            }
            public override void Link()
            {
            }
            public class Context : System.Text.Parsing.Context
            {
                public RuleParser rule;
                public ParsingContext ctx;
            }
        }
        public override void GetReferencedGrammars()
        {
        }
        public override void CreateRules()
        {
            AddRuleLink(new RuleLink("Identifier", this, "ElementGrammar.Identifier"));
            AddRuleLink(new RuleLink("Signature", this, "ElementGrammar.Signature"));
            AddRuleLink(new RuleLink("Alternative", this, "CompositeGrammar.Alternative"));
            AddRule(new RuleRule("Rule", GetScope(), Domain.GetNextRuleId(),
                new SequenceParser(
                    new SequenceParser(
                        new ActionParser("",
                            new NonterminalParser("RuleHeader", "RuleHeader", 2)),
                        new StringParser("::=")),
                    new NonterminalParser("RuleBody", "RuleBody", 2))));
            AddRule(new RuleHeaderRule("RuleHeader", GetScope(), Domain.GetNextRuleId(),
                new SequenceParser(
                    new ActionParser("",
                        new NonterminalParser("name", "Identifier", 0)),
                    new NonterminalParser("Signature", "Signature", 2))));
            AddRule(new RuleBodyRule("RuleBody", GetScope(), Domain.GetNextRuleId(),
                new ActionParser("",
                    new SequenceParser(
                        new ExpectationParser(
                            new NonterminalParser("definition", "Alternative", 2)),
                        new ExpectationParser(
                            new CharParser(';'))))));
        }
    }
}
